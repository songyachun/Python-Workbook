
Todo:
  ✔ python 内存管理机制 @done(20-03-18 16:50)
  简单来说python的内存管理机制有三种
  1）引用计数
  当一个python对象被引用时其引用计数增加1，当其不再被引用时引用计数减1，当引用计数等于0时，对象被删除。
  2）垃圾回收
  ①  引用计数
  引用计数也是一种垃圾回收机制，而且是一种最直观，最简单的垃圾回收技术。
  在Python中每一个对象的核心就是一个结构体PyObject，它的内部有一个引用计数 ob_refcnt，当python的某个对象引用计数为0。就说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。
  
  举个栗子: 当一个对象被创建出来，他的引用计数就会+1，当对象被引用的时候，计数继续增加，当引用它的对象被删除的时候，它的引用计数就会减少。直到变为0，此时垃圾回收机制就会把它回收。但是一旦出现循环引用，我们就得采取新的办法了。
  ②  标记清除
  标记清除用来解决循环引用产生的问题，循环引用只有在容器对象才会产生，比如字典，元祖，列表等。首先为了追踪对象，需要每个容器对象维护两个额外的指针，用来将容器对象组成一个链表，指针分别指向前后两个容器对象，这样可以将对象的循环引用摘除，就可以得出两个对象的有效计数。
  ③  分代回收  
  了解分类回收，首先要了解一下，GC的阈值，所谓阈值就是一个临界点的值。
  随着你的程序运行，Python解释器保持对新创建的对象，以及因为引用计数为零而被释放掉的对象的追踪。从理论上说，创建==释放数量应该是这样子。但是如果存在循环引用的话，肯定是创建>释放数量，当创建数与释放数量的差值达到规定的阈值的时候，当当当当~分代回收机制就登场啦。
  分代回收思想将对象分为三代（generation 0,1,2）
    0代表幼年对象，
    1代表青年对象，
    2代表老年对象。
  根据弱代假说（越年轻的对象越容易死掉，老的对象通常会存活更久。）
  新生的对象被放入0代，如果该对象在第0代的一次gc垃圾回收中活了下来，那么它就被放到第1代里面（它就升级了）。如果第1代里面的对象在第1代的一次gc垃圾回收中活了下来，它就被放到第2代里面。
  从上一次第0代gc后，如果分配对象的个数减去释放对象的个数大于threshold0，那么就会对第0代中的对象进行gc垃圾回收检查。
  从上一次第1代gc后，如果第0代被gc垃圾回收的次数大于threshold1，那么就会对第1代中的对象进行gc垃圾回收检查。
  从上一次第2代gc后，如果第1代被gc垃圾回收的次数大于threshold2，那么就会对第2代中的对象进行gc垃圾回收检查。
  gc每一代垃圾回收所触发的阈值可以自己设置。
  3）内存池
  Python的内存机制呈现金字塔形状，-1，-2层主要有操作系统进行操作
  第0层是C中的malloc，free等内存分配和释放函数进行操作
  第1层和第2层是内存池，有python接口函数，PyMem_Malloc函数实现，当对象小于256k的时由该层直接分配内存
  第3层是最上层，也就是我们对python对象的直接操作
  Python在运行期间会大量地执行malloc和free的操作，频繁地在用户态和核心态之间进行切换，这将严重影响Python的执行效率。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。

  4，调优手段
    1.手动垃圾回收
    2.避免循环引用（手动解循环引用和使用弱引用）
    3.调高垃圾回收阈值


  ✔ 浅拷贝 和深拷贝 @done(20-03-18 18:31)
  赋值（=），就是创建了对象的一个新的引用，修改其中任意一个变量都会影响到另一个。
  浅拷贝：创建一个新的对象，但它包含的是对原始对象中包含项的引用（如果用
  引用的方式修改其中一个对象，另外一个也会修改改变）{1,完全切片方法；2，
  工厂函数，如 list()；3，copy 模块的 copy()函数}
  深拷贝：创建一个新的对象，并且递归的复制它所包含的对象（修改其中一个，
  另外一个不会改变）{copy 模块的 deep.deepcopy()函数}

  ✔ 局部变量和全局变量 @done(20-03-18 18:31)
  Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。
  当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：
  本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in

☐ 未完，多线程....

